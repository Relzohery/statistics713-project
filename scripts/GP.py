import numpy as np
from numpy import linalg as LA
import scipy.io as spio



names = ['U234','U235','U236', 'U238','Np236','Np237','Pu238','Pu239','Pu240','Pu241',
         'Pu242','Pu243','Pu244','Am241','Am242m','Am243','Cm242','Cm243','Cm244','Cs133',
         'Cs134','Cs135','Cs137','Gd154','Gd155','Gd156','Tc99','Mo95','Kr83','Zr90','Zr91',
         'Zr95','Zr93','Zr96','Zr94','Nb93','Mo97','Mo99','Ru101','Pd105','Ag109','I127','I129',
         'Xe131','Nd143','Nd145','Sm147','Sm149','Sm150','Sm151','Sm152','Eu153','Eu154','Eu155',
         'Ru103','Xe135','Pm147','Rh103','Ce144','Cd113','Eu151']

fuel_materials = ['12020000', '12020001', '12020002']

No_seg = 3


def read_dep_data(fname):
    '''
    Inputs:
        file name, _dep.m file generated by Serpent
    Outputs:
        Adens: numpy array containing the time dependent atomic densities
              for the three segments
        bu_steps: list of the burnup steps
    '''
    time = None
    with open(fname) as f:
        Adens = []
        for line in f:
            if 'DAYS' in line and time is None:
                time = list(map(float, (line.split('=')[1].split()[1:-1])))
            for mat_no, mat in enumerate(fuel_materials):
                if 'MAT_{}_ADENS'.format(mat) in line:
                     for no, name in enumerate(names):
                        info = list(map(float, next(f).split()[:-2]))
                        Adens.append(info)
        Adens = np.reshape(Adens, (len(names)* len(fuel_materials), len(time)))

    return Adens, time


train_data = read_dep_data('/home/rabab/Research/ROM/ans2018dmdgp/data/case_study_1_dep.m')

data = train_data[0]
times = np.array(train_data[1])


U, S, V = np.linalg.svd(data)

r = 10

Ur = U[:, :r]

a = Ur.T@data

#%%
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
import matplotlib.pylab as plt
import time

t1 = time.time()
a_predict = np.zeros(a.shape)
## Gaussian Process
# Instantiate a Gaussian Process model
kernel = 100 * RBF(100, (1e-2, 1e2))

for i in range(len(a)):
    gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)  
    X = times.reshape(-1, 1)
    y = a[i, :]
    gp.fit(X, y)
    
    y_pred, sigma = gp.predict(X, return_std=True)
    a_predict[i, :] = y_pred
t2 = time.time()    
    
iso_pred = Ur@a_predict
t = t2-t1

#%%
error = np.linalg.norm(iso_pred - data)/np.linalg.norm(data)
iso = 1
plt.plot(abs(iso_pred[iso, :] - data[iso, :])/data[iso, :]*100)